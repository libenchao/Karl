# leetcode summary

## hash
将需要查找的信息存放到hash容器中，典型的hash容器有```unordered_map```, ```unordered_set```. 另外，如果需要排序的hash容器，则使用```map```, ```set```即可。

当然了，每一种map和set都有对应的multimap和multiset来处理有重复的情形。

-- 题目列表 --

* 001 未排序的数组中找到另个数字的下标，使得其sum为target
* 003 一个字符串中最长的没有重复字母的字串

## sort

## string

## linked list
链表问题是比较经典的问题，主要是考察对于链表的编程熟练程度，而算法的考察时次要的。链表问题最重要的注意事项就是头结点的改变，结尾NULL的处理。头结点的改变可以采用添加一下临时的头结点来减少编程复杂度。

-- 题目列表 --

* 002 两个用链表表示的整数的加法


## two points
该类问题主要是利用两个指针来划定一个范围，该范围内的数据是满足条件的；而right指针往右移动说明当前范围正在扩展，left指针往右移动的时候，说明范围在缩小。该算法的中文名称应该是“卡尺法”。

-- 题目列表 --

* 003 一个字符串中最长的没有重复字母的字串

## graph

## binary tree

## binary search tree

## binary search
二分搜索是比较典型的算法，也是最常用的算法之一，可以跟很多别的算法混合使用。通常可以将算法的复杂度从n降低到nlogn，是非常实用的算法。

该算法主要需要注意的问题有两个，一个是mid的计算的问题，mid计算有两种方式，```mid = left + (right-left)/2;``` 和 ```mid = (left + right) / 2``` 。 两种方式的区别在于，如果下标都是正的，应该用前一种，可以避免溢出。

第二个问题是```==```的情况的处理。如果是搜索满足条件的下界，通常是用```mid = (left+right)/2```， 而<时```left = mid+1```； >=时```right = mid```。 如果是搜索满足条件的上界，通常使用```mid = (left+right+1)/2```， 而>时， ```right = mid-1```； <=时```left = mid```。

当然了，如果搜索条件是”是否存在”，则可以在找到一个元素的时候直接返回了，情况更简单一些。

-- 题目列表 --

* 004 在两个排序的数组中找中位数

## divide and conquer
分治法也是很典型的算法，跟二分搜索差不多。或者说二分搜索就是分治法的典型应用。分治法通常也是可以有效降低复杂度的算法，可以把n变为logn。归并排序是最典型的分治法的题目。

-- 题目列表 --

* 004 在两个排序的数组中找中位数

## string
严格来讲，这不是一类算法。主要是很多问题都是以字符串的形式给出，并且没有明确的算法与之对应，就将其对应到了该类算法下了。

比如Manchester算法，用来求最长回文字串的算法，可以将算法降低到n

-- 题目列表 --

* 005 最长回文字串
* 006 ZigZag遍历访问字符串
* 